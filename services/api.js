/**
 * Module to isolate calls to discord API endpoints.
 */

require("dotenv").config()

const { REST, Routes } = require("discord.js")
const { logger } = require("../util/logger")

const client = new REST().setToken(process.env.BOT_TOKEN)

const botId = process.env.CLIENT_ID

/**
 * Create JSON for a set of commands
 *
 * The JSON uses each command's data() method for generation. This method must return an object with its
 * own toJSON implementation.
 *
 * @param  {Command[]} cmds Array of command objects
 * @return {Object[]}       Array of generated JSON for the given commands
 */
function commandsToJSON(cmds) {
  return cmds.map((c) => c.data().toJSON())
}

module.exports = {
  client,
  commandsToJSON,

  /**
   * Get the list of deployed global commands
   *
   * @return {Promise<Array>} Promise resolving to an array of command objects
   */
  async getGlobalCommands() {
    logger.info("Begin getting global commands")
    return client
      .get(Routes.applicationCommands(botId))
      .catch((error) => {
        logger.warn(error, "Error getting global commands")
      })
      .finally(() => {
        logger.info("Done getting global commands")
      })
  },

  /**
   * Overwrite the deployed global commands
   *
   * This pushes all global commands to discord, replacing whatever's already there for the bot.
   *
   * @return {Promise} Promise resolving to the endpoint's response
   */
  async setGlobalCommands() {
    const commands = require("../commands")
    const global_json = commandsToJSON(commands.global)

    logger.info("Begin setting global commands")
    return client
      .put(Routes.applicationCommands(botId), {
        body: global_json,
      })
      .catch((error) => {
        logger.warn(error, "Error setting global commands")
      })
      .finally(() => {
        logger.info("Done setting global commands")
      })
  },

  /**
   * Update a single global command
   *
   * This is useful for tweaking the data of a single command without replacing anything else. Requires the
   * command ID generated by discord.
   *
   * @param  {string}    commandName Name of the command to update
   * @param  {Snowflake} commandId   Discord ID of the command as deployed
   * @return {Promise}               Promise resolving to the endpoint's response
   */
  async updateGlobalCommand(commandName, commandId) {
    const commands = require("../commands")
    const command_json = commands.global.get(commandName).data().toJSON()

    logger.info({ command: commandName }, "Begin updating global command")
    return client
      .patch(Routes.applicationCommand(botId, commandId), {
        body: command_json,
      })
      .catch((error) => {
        logger.warn(error, `Error updating global command ${commandName}`)
      })
      .finally(() => {
        logger.info({ command: commandName }, "Done updating global command")
      })
  },

  /**
   * Get the guilds the bot is installed in
   *
   * @return {Promise<Array>} Promise resolving to an array of guild objects
   */
  async getGuilds() {
    logger.info("Begin getting installed guilds")
    return client
      .get(Routes.userGuilds(botId))
      .catch((error) => {
        logger.warn(error, "Error getting guilds")
      })
      .finally(() => {
        logger.info("Done getting guilds")
      })
  },

  /**
   * Get the commands deployed to a guild
   *
   * @param  {Snowflake} guildId Guild ID to query
   * @return {Promise<Array>}    Promise resolving to an array of command objects
   */
  async getGuildCommands(guildId) {
    logger.info({ guild: guildId }, "Begin getting guild commands")
    return client
      .get(Routes.applicationGuildCommands(botId, guildId))
      .catch((error) => {
        logger.warn(error, `Error getting guild commands for ${guildId}`)
      })
      .finally(() => {
        logger.info({ guild: guildId }, "Done getting guild commands")
      })
  },

  /**
   * Overwrite the deployed guild commands
   *
   * This replaces whatever commands are on the given guild with a new set. If commandNames is supplied, those
   * commands will be sent. Otherwise, all commands will be sent. If commandNames is an empty array, then all
   * existing commands will be removed, but no new ones will take their place.
   *
   * @param {Snowflake} guildId      Guild ID whose commands will be overwritten
   * @param {string[]}  commandNames Array of command names to set. Optional.
   * @return {Promise}               Promise resolving to the endpoint response
   */
  async setGuildCommands(guildId, commandNames) {
    const commands = require("../commands")
    const guild_commands = commands.guild
    let new_commands = guild_commands
    if (typeof commandNames !== "undefined") {
      new_commands = guild_commands.filter((c) => commandNames.includes(c.name))
    }
    const guild_json = commandsToJSON(new_commands)

    logger.info({ guild: guildId, commands: commandNames }, "Begin setting guild commands")
    return client
      .put(Routes.applicationGuildCommands(botId, guildId), {
        body: guild_json,
      })
      .catch((error) => {
        logger.warn(error, `Error setting guild commands for ${guildId}`)
      })
      .finally(() => {
        logger.info({ guild: guildId }, "Done setting guild commands")
      })
  },

  /**
   * Update a single guild command
   *
   * This is useful for tweaking the data of a single command without replacing anything else. Requires the
   * command ID generated by discord.
   *
   * @param  {Snowflake} guildId     The guild ID to update
   * @param  {string}    commandName Name of the command to update
   * @param  {Snowflake} commandId   Discord ID of the command as deployed
   * @return {Promise}               Promise resolving to the endpoint's response
   */
  async updateGuildCommand(guildId, commandName, commandId) {
    const commands = require("../commands")
    const command_json = commands.guild.get(commandName).data().toJSON()

    logger.info({ guild: guildId, command: commandName }, "Begin updating guild command")
    return client
      .patch(Routes.applicationGuildCommand(botId, guildId, commandId), {
        body: command_json,
      })
      .catch((error) => {
        logger.warn(error, `Error updating guild command ${commandName} for ${guildId}`)
      })
      .finally(() => {
        logger.info({ guild: guildId, command: commandName }, "Done updating guild command")
      })
  },
}
